================================================================================
                    LABORATÓRIO 11 - RESPOSTAS DA ENTREGA
                Pool de Threads e Computação Assíncrona em Java
================================================================================

ATIVIDADE 1 - ITEM 4: Implementação da Classe Primo
--------------------------------------------------------------------------------

Localização: atividade1/MyPool.java (linhas 129-153)

Implementação:
- A classe Primo implementa a interface Runnable
- Recebe um número inteiro positivo no construtor
- O método ehPrimo(long n) verifica se o número é primo usando:
  * Casos base: n <= 1 (não primo), n == 2 (primo), n par (não primo)
  * Loop de 3 até sqrt(n), incrementando de 2 em 2 (apenas ímpares)
- O método run() imprime se o número é primo ou não

Funcionamento:
- As tarefas Primo são executadas pelo pool de threads personalizado (FilaTarefas)
- Cada thread do pool retira uma tarefa da fila e executa
- A saída mostra a verificação de primos de 0 a 24 em ordem não determinística
  devido à execução concorrente

Saídas de teste:
- saida-mypool-primo.txt (10 threads)
- saida-mypool-primo-2threads.txt
- saida-mypool-primo-5threads.txt
- saida-mypool-primo-15threads.txt

Primos encontrados no intervalo [0, 24]: 2, 3, 5, 7, 11, 13, 17, 19, 23


ATIVIDADE 3 - ITENS 2 E 3: Contagem de Primos com Computação Assíncrona
--------------------------------------------------------------------------------

Localização: atividade3/FutureHello.java

Item 2 - Classe PrimoCallable (linhas 32-63):
- Implementa a interface Callable<Long>
- Recebe um intervalo [inicio, fim] no construtor
- O método call() retorna a quantidade de primos no intervalo
- Usa o mesmo algoritmo de verificação de primalidade da Atividade 1

Item 3 - Contagem total de primos de 1 a N (linhas 66-110):
- Divide o intervalo [1, N] em blocos iguais entre as threads
- Cada thread (PrimoCallable) conta os primos em seu bloco
- Usa Future.get() para recuperar os resultados de cada thread
- Soma todos os resultados parciais para obter o total

Funcionamento:
1. Cria um pool de 10 threads (ExecutorService)
2. Divide N em 10 blocos (ex: para N=1000000, cada bloco tem 100000 números)
3. Submete cada bloco como uma tarefa Callable
4. Aguarda os resultados com future.get() (bloqueante)
5. Soma os resultados parciais
6. Imprime a quantidade total de primos

Vantagem da computação assíncrona:
- As threads trabalham em paralelo em diferentes partes do intervalo
- O tempo total é aproximadamente tempo_sequencial / numero_de_threads
- Para N grande, o ganho de desempenho é significativo

Saídas de teste:
- saida-futurehello-100.txt      -> 25 primos em [1, 100]
- saida-futurehello-10000.txt    -> 1.229 primos em [1, 10.000]
- saida-futurehello.txt          -> 78.498 primos em [1, 1.000.000]
- saida-futurehello-10000000.txt -> 664.579 primos em [1, 10.000.000]


VALORES DE ENTRADA E RESULTADOS OBTIDOS
--------------------------------------------------------------------------------

Atividade 1 - MyPool com Primo:
  Entrada: números de 0 a 24 (25 tarefas)
  Variações de NTHREADS: 2, 5, 10, 15

  Resultados (primos encontrados):
  - 2, 3, 5, 7, 11, 13, 17, 19, 23
  - Total: 9 primos
  - Observação: com mais threads, a saída fica mais desordenada

Atividade 1 - MyPool com Hello:
  Entrada: 25 tarefas ("Hello da tarefa 0" até "Hello da tarefa 24")
  Variações de NTHREADS: 2, 5, 15

  Resultados:
  - 2 threads: saída quase sequencial
  - 5 threads: saída moderadamente desordenada
  - 15 threads: saída bem embaralhada

Atividade 2 - AnotherHelloPool com contador:
  Entrada: 49 workers (1 a 49), cada um calcula soma de 1 até i
  NTHREADS: 10

  Resultados:
  - Somas calculadas corretamente (0, 1, 3, 6, 10, ..., 1176)
  - Contador final: 49 (todas as 49 tarefas executadas)

Atividade 3 - FutureHello com contagem de primos:
  Variações de N (limite superior do intervalo):

  | N          | NTHREADS | Primos encontrados |
  |------------|----------|--------------------|
  | 100        | 10       | 25                 |
  | 10.000     | 10       | 1.229              |
  | 1.000.000  | 10       | 78.498             |
  | 10.000.000 | 10       | 664.579            |


AVALIAÇÃO DA CORRETUDE DOS PROGRAMAS
--------------------------------------------------------------------------------

1. Atividade 1 (MyPool com Primo):
   - Comparei os resultados com a lista conhecida de primos de 0 a 24
   - Primos esperados: 2, 3, 5, 7, 11, 13, 17, 19, 23 (9 primos)
   - Todas as execuções identificaram corretamente esses 9 primos
   - A ordem de saída varia entre execuções (comportamento esperado da concorrência)

2. Atividade 2 (AnotherHelloPool com contador):
   - Verifiquei que o contador final = 49 (número de workers executados)
   - Usei AtomicLong para garantir incremento thread-safe sem race conditions

3. Atividade 3 (FutureHello com contagem de primos):
   - Comparei os resultados com valores conhecidos da função pi(n):
     * pi(100) = 25 primos ✓
     * pi(10.000) = 1.229 primos ✓
     * pi(1.000.000) = 78.498 primos ✓
     * pi(10.000.000) = 664.579 primos ✓
   - Todos os valores correspondem aos valores matemáticos tabelados
   - A soma dos resultados parciais das threads é consistente com o total


DOCUMENTAÇÃO ADICIONAL
--------------------------------------------------------------------------------

Classe FilaTarefas (atividade1/MyPool.java):
- Documentação completa com JavaDoc adicionada à classe
- Explica o funcionamento do pool de threads personalizado
- Documenta atributos, construtores e métodos
- Inclui comentários inline no código

Classe AnotherHelloPool (atividade2/AnotherHelloPool.java):
- Modificada para incluir variável compartilhada (AtomicLong contador)
- Cada thread incrementa o contador ao terminar sua tarefa
- Exibe o valor final do contador ao término da execução


ESTRUTURA DE ARQUIVOS
--------------------------------------------------------------------------------

laboratorio11/
├── roteiro-lab11.pdf
├── respostas-entrega.txt
├── atividade1/
│   ├── MyPool.java (código fonte com documentação)
│   ├── *.class (arquivos compilados)
│   └── saida-*.txt (saídas de teste)
├── atividade2/
│   ├── HelloPool.java
│   ├── AnotherHelloPool.java (com contador compartilhado)
│   ├── *.class
│   └── saida-*.txt
└── atividade3/
    ├── FutureHello.java (código fonte com PrimoCallable)
    ├── *.class
    └── saida-*.txt

================================================================================
